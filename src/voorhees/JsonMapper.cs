using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace Voorhees {
    /// Maps json data to values of specific types, and vice-versa.
    /// Uses any (optional) json importer and/or exporter functions
    /// registered for specific types.
    /// Writes values to JsonTokenWriter and reads values from JsonTokenReader.
    public partial class JsonMapper { // statics
        /// <summary>
        /// High level API.
        /// Generates a JSON string by serializing the given object.
        /// </summary>
        /// <param name="val">The value to serialize</param>
        /// <param name="prettyPrint">If true, adds newlines and tabs to nicely format the json.  If false, generates as compact json as possible.</param>
        /// <typeparam name="T">The type of <paramref name="val"/></typeparam>
        /// <returns>The JSON string generated by serializing <paramref name="val"/></returns>
        public static string ToJson<T>(T val, bool prettyPrint = false) {
            var stringBuilder = new StringBuilder();
            using (var stringWriter = new StringWriter(stringBuilder)) {
                defaultInstance.Write(val, new JsonTokenWriter(stringWriter, prettyPrint));
            }
            return stringBuilder.ToString();
        }
        
        public static T FromJson<T>(string json) {
            return defaultInstance.Read<T>(new JsonTokenReader(new StringReader(json)));
        }

        static readonly JsonMapper defaultInstance = new();
    }

    public partial class JsonMapper { // importers and exporters
        public delegate void ExporterFunc<in T>(T objectToSerialize, JsonTokenWriter tokenWriter);

        public delegate T ImporterFunc<out T>(JsonTokenReader tokenReader);

        /////////////////////////////////////////////////

        /// <summary>
        /// Write a value to a token writer.
        /// </summary>
        /// <param name="val">The value to write</param>
        /// <param name="tokenWriter">The tokenWriter to write the Json tokens to</param>
        /// <typeparam name="T">The type of <paramref name="val"/></typeparam>
        public void Write<T>(T val, JsonTokenWriter tokenWriter) {
            WriteValue(val, typeof(T), val?.GetType(), tokenWriter);
        }

        /// <summary>
        /// Read a value from a token reader
        /// </summary>
        /// <param name="tokenReader">The token reader to read from</param>
        /// <typeparam name="T">The type of value to read</typeparam>
        /// <returns>A new instance of the value type de-serialized from the json data.</returns>
        /// <exception cref="InvalidJsonException">If the json being read is invalid or the json data is not fully consumed by reading.</exception>
        public T Read<T>(JsonTokenReader tokenReader) {
            var result = ReadValueOfType<T>(tokenReader);
            
            // Make sure there's no additional json in the buffer.
            if (tokenReader.NextToken != JsonToken.EOF) {
                throw new InvalidJsonException($"{tokenReader.LineColString} Expected end of file");
            }
            return result;
        }
        
        #region Importers
        public void RegisterImporter<T>(ImporterFunc<T> importer) => importers[typeof(T)] = json => importer(json);
        public void UnRegisterImporter<T>() => importers.Remove(typeof(T));
        public void UnRegisterAllImporters() => importers.Clear();
        #endregion
        
        #region Exporters
        public void RegisterExporter<T>(ExporterFunc<T> exporter) => exporters[typeof(T)] = (obj, os) => exporter((T)obj, os);
        public void UnRegisterExporter<T>() => exporters.Remove(typeof(T));
        public void UnRegisterAllExporters() => exporters.Clear();
        #endregion
        
        /////////////////////////////////////////////////
        
        delegate void ExporterFunc(object obj, JsonTokenWriter os);
        delegate object ImporterFunc(JsonTokenReader tokenReader);
        
        readonly Dictionary<Type, ImporterFunc> importers = new();
        readonly Dictionary<Type, ExporterFunc> exporters = new();
    }
}
