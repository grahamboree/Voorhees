using System.IO;
using System.Text;

namespace Voorhees {
    /// Maps json data to values of specific types, and vice-versa.
    /// Uses any (optional) json importer and/or exporter functions
    /// registered for specific types.
    /// Writes values to JsonTokenWriter and reads values from JsonTokenReader.
    public partial class JsonMapper { // statics
        #region Static Methods
        /// <summary>
        /// Generates a JSON string by serializing the given object.
        /// </summary>
        /// <param name="val">The value to serialize</param>
        /// <param name="prettyPrint">If true, adds newlines and tabs to nicely format the json.  If false, generates as compact json as possible.</param>
        /// <typeparam name="T">The type of <paramref name="val"/></typeparam>
        /// <returns>The JSON string generated by serializing <paramref name="val"/></returns>
        public static string ToJson<T>(T val, bool prettyPrint = false) {
            var stringBuilder = new StringBuilder();
            using (var stringWriter = new StringWriter(stringBuilder)) {
                defaultInstance.Write(val, new JsonTokenWriter(stringWriter, prettyPrint));
            }
            return stringBuilder.ToString();
        }

        /// <summary>
        /// Writes a JSON representation of <paramref name="val"/> to <paramref name="textWriter"/>
        /// </summary>
        /// <param name="val">The value to write</param>
        /// <param name="textWriter">Where to write JSON data</param>
        /// <param name="prettyPrint">If true, adds newlines and tabs to nicely format the json.  If false, generates as compact json as possible.</param>
        /// <typeparam name="T">The type of <paramref name="val"/></typeparam>
        public static void ToJson<T>(T val, TextWriter textWriter, bool prettyPrint = false) {
            defaultInstance.Write(val, new JsonTokenWriter(textWriter, prettyPrint));
        }
        
        /// <summary>
        /// Reads a value from a json string.
        /// </summary>
        /// <param name="json">The json to parse</param>
        /// <typeparam name="T">The type of the value to be read</typeparam>
        /// <returns>A new instance of type <typeparamref name="T"/> with values read from <paramref name="json"/></returns>
        public static T FromJson<T>(string json) {
            return defaultInstance.Read<T>(new JsonTokenReader(new StringReader(json)));
        }

        /// <summary>
        /// Reads a value from a json stream.
        /// </summary>
        /// <param name="textReader">The stream to read from</param>
        /// <typeparam name="T">The type of the value to be read</typeparam>
        /// <returns>A new instance of type <typeparamref name="T"/> with values read from <paramref name="textReader"/></returns>
        public static T FromJson<T>(TextReader textReader) {
            return defaultInstance.Read<T>(new JsonTokenReader(textReader));
        }
        #endregion

        /// <summary>
        /// Writes the json representation of <paramref name="val"/> to <paramref name="tokenWriter"/>.
        /// Uses any custom exporters registered to this mapper instance, or defaults to the normal memberwise serializer
        /// </summary>
        /// <param name="val">The value to write</param>
        /// <param name="tokenWriter">The tokenWriter to write the Json tokens to</param>
        /// <typeparam name="T">The type of <paramref name="val"/></typeparam>
        public void Write<T>(T val, JsonTokenWriter tokenWriter) {
            var numeric = Internal.NumericValueParsers.Get<T>();
            if (numeric != null) {
                numeric.WriteTo(val, tokenWriter);
            } else {
                WriteValue(val, typeof(T), val?.GetType(), tokenWriter);
            }
        }

        /// <summary>
        /// Read a value of type <typeparamref name="T"/> from <paramref name="tokenReader"/>.
        /// Uses any custom importers registered to this mapper instance, or defaults to the normal memberwise deserializer.
        /// </summary>
        /// <param name="tokenReader">The token reader to read from</param>
        /// <typeparam name="T">The type of value to read</typeparam>
        /// <returns>A new instance of the value type de-serialized from the json data.</returns>
        /// <exception cref="InvalidJsonException">If the json being read is invalid or the json data is not fully consumed by reading.</exception>
        public T Read<T>(JsonTokenReader tokenReader) {
            var result = ReadValueOfType<T>(tokenReader);
            
            // Make sure there's no additional json in the buffer.
            if (tokenReader.NextToken != JsonToken.EOF) {
                throw new InvalidJsonException($"{tokenReader.LineColString} Expected end of file");
            }
            return result;
        }
        
        #region Custom Importers
        /// <summary>
        /// A custom method for reading a value of type <typeparamref name="T"/> from a <c>JsonTokenReader</c>
        /// </summary>
        /// <typeparam name="T">The type of object to read</typeparam>
        public delegate T ImporterFunc<out T>(JsonTokenReader tokenReader);

        /// <summary>
        /// Register a function that produces values of type <typeparamref name="T"/> from JSON data.
        /// </summary>
        /// <param name="importer">A custom importer function for values of type <typeparamref name="T"/></param>
        /// <typeparam name="T">The type of value produced</typeparam>
        public void RegisterImporter<T>(ImporterFunc<T> importer) => importers[typeof(T)] = json => importer(json);
        
        /// <summary>
        /// Unregisters any currently registered custom importer for values of type <typeparamref name="T"/> 
        /// </summary>
        /// <typeparam name="T">The type produced by the custom importer</typeparam>
        public void UnRegisterImporter<T>() => importers.Remove(typeof(T));
        
        /// <summary>
        /// Clears all currently registered custom importers.
        /// </summary>
        public void UnRegisterAllImporters() => importers.Clear();
        #endregion
        
        #region Custom Exporters
        /// <summary>
        /// A custom method for writing a value of type <typeparamref name="T"/> to a <c>JsonTokenWriter</c>
        /// </summary>
        /// <typeparam name="T">The type of object to write</typeparam>
        public delegate void ExporterFunc<in T>(T objectToSerialize, JsonTokenWriter tokenWriter);
        
        /// <summary>
        /// Registers a function that produces JSON given a value of type <typeparamref name="T"/>
        /// </summary>
        /// <param name="exporter">A custom exporter function for values of type <typeparamref name="T"/></param>
        /// <typeparam name="T">The type of values this function converts to JSON</typeparam>
        public void RegisterExporter<T>(ExporterFunc<T> exporter) => exporters[typeof(T)] = (obj, os) => exporter((T)obj, os);
        
        /// <summary>
        /// Unregisters any currently registered custom exporter for values of the type <typeparamref name="T"/>
        /// </summary>
        /// <typeparam name="T">The type of values the exporter converts to JSON</typeparam>
        public void UnRegisterExporter<T>() => exporters.Remove(typeof(T));
        
        /// <summary>
        /// Clears all currently registered custom exporters.
        /// </summary>
        public void UnRegisterAllExporters() => exporters.Clear();
        #endregion
    }
}
